# 整数划分：
- n=m1+m2+...+mi; （其中mi为正整数，并且1 <= mi <= n），则{m1,m2,...,mi}为n的一个划分。
- 如果{m1,m2,...,mi}中的最大值不超过m，即max(m1,m2,...,mi)<=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);
- 举个例子，当n=5时我们可以获得以下这几种划分（注意，例子中m>=5）

5 = 5   
   = 4 + 1   
   = 3 + 2   
   = 3 + 1 + 1   
   = 2 + 2 + 1   
   = 2 + 1 + 1 + 1   
   = 1 + 1 + 1 + 1 + 1  
**以下将正整数划分分为三种题型：1.一般性，即对个数以及大小以及重复性不加约束 2.对重复性有约束 3.对元素的个数有约束。
至于每个元素的大小则可以归并到第一类题：通过更改p(n,m)的参数m即可。**  
## 解题思路  
如题，令p(n)表示正整数n的划分数，则难以找到递归关系，因此增加一个自变量m，设定最大加数n1不大于m的划分个数。即p(n)=q(n,m)，则有以下关系：

1. 首先当n=0：return 1:表示已经被分完

2. m=0:则无法实现，即return 0

3. 当m=1 or n=1：则return 1(n=1:则由1组成；m=1：则由n个1组成这两种情况都是一种方式)  
   不论n的值为多少，只有一种划分即n个1，{1,1,1,...,1}; 

4. 当n<m则满足：q(n,m)=q(n,n) :n的划分由n1<=n的划分组成

5. 当n=m：根据划分中是否包含n，可以分为两种情况：  
  (1) 划分中包含n的情况，只有一个即{n}；   
  (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。  
  因此 q(n,n) =1 + q(n,n-1); 

6. n>m>1时，根据划分中是否包含最大值m，可以分为两种情况：

  (1) 划分中包含m的情况，即{m, {x1,x2,...xi}}, 其中{x1,x2,... xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m); 
  (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);  
  因此 q(n,m)=q(n,m-1)+q(n-m,m)
  
---  
综合以上情况，我们可以看出，上面的结论具有递归定义特征，其中（1）和（2）属于回归条件，（3）和（4）属于特殊情况，将会转换为情况（5）。
而情况（5）为通用情况，属于递推的方法，其本质主要是通过减小m以达到回归条件，从而解决问题。  

**对重复性有约束情况**

此时我们需要调整我们的状态转换公式。

p(n-m,m)+p(n,m-1); (n>m) 应该更改为：p(n-m,m-1)+p(n,m-1); (n>m)

为什呢？因为每个数最多使用一次，p(n-m,m-1)表示我们取了数m，p(n,m-1)表示我们没取，但是无论取不取数m我们以后都不会再次取数m了。

当然喽，我们还需要调整边界状态：当m=1时，p(n,m)=1；当n=1而m>1时，f(n,m)=0。其他不变！
